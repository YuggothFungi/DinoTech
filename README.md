# DinoTech

Good dinosaurs code, great dinosaurs vibecode.

# Архитектура PWA‑приложения для управления товарами, техкартами, упаковкой и себестоимостью

---

## 0. Ключевые сценарии использования (с чего начинается работа с системой)

Этот раздел описывает **что именно можно сделать с помощью приложения**. Он является опорным: все остальные разделы спецификации обязаны быть с ним согласованы.

### Сценарий A. Создание нового напитка (manufactured) с упаковкой

1. Пользователь создаёт **Product** типа `manufactured` (например, «Капучино 300 мл»).
2. Пользователь назначает товару **категорию** (Напитки → Кофе → Классический).
3. Пользователь создаёт **TechCard**, указывая:
   * выход продукта (300 мл);
   * ингредиенты (кофе, молоко и т.д.).
4. Пользователь настраивает **упаковку товара**:
   * стакан 300 мл (1 шт);
   * крышка большая (1 шт).
5. Система может выполнить **предварительный расчёт себестоимости** (preview).
6. Пользователь фиксирует расчёт, создавая **CostCalculation**.
7. Пользователь задаёт **цену продажи** через модель ценообразования (наценка или фиксированная маржа).

---

### Сценарий B. Изменение упаковки без изменения рецептуры

1. Поставщик стаканчиков меняется, появляется новая цена.
2. Пользователь вводит новый **PriceRecord** для соответствующего Packaging.
3. Система показывает список товаров, где изменилась себестоимость **из‑за упаковки**.
4. Пользователь выполняет массовый пересчёт себестоимости.
5. Рецептуры (TechCard) при этом **не меняются**.

---

### Сценарий C. Изменение объёма напитка

1. Пользователь создаёт новый **Product** (например, «Капучино 400 мл»).
2. К нему может быть:
   * переиспользована TechCard с другими коэффициентами;
   * назначена другая упаковка (стакан 400 мл + крышка большая).
3. Себестоимость и цена продажи считаются независимо от версии 300 мл.

---

### Сценарий D. Подорожало сырьё или упаковка

1. Пользователь вводит новый **PriceRecord** (сырьё или упаковка).
2. Система определяет затронутые товары.
3. Пользователь:
   * просматривает изменение себестоимости (preview);
   * принимает решение о пересчёте;
   * при необходимости обновляет цены продажи.

---

### Сценарий E. Работа офлайн

1. Пользователь открывает PWA без сети.
2. Управляет товарами, техкартами, упаковкой.
3. Выполняет расчёты себестоимости локально.
4. При появлении сети изменения синхронизируются.

---

## 1. Общее описание

**Цель**: создание прогрессивного веб‑приложения (PWA) для управления ассортиментом товаров кофейни, технологическими картами, упаковкой, закупочными ценами и расчётом себестоимости и цен продажи с поддержкой офлайн‑режима и синхронизации.

Система ориентирована на **управленческий и операционный учёт**, а не на бухгалтерский или складской.

---

## 2. Доменная модель (ключевые понятия)

### 2.1. Product (товар)

Центральная сущность системы — всё, что продаётся клиенту.

**Типы**:
* `manufactured` — производится по техкарте;
* `resale` — перепродаётся без переработки.

**Ключевые атрибуты**: `id`, `name`, `sku`, `type`, `categoryId`, `isActive`.

---

### 2.2. Category (категория)

Иерархическая группировка товаров для навигации и аналитики.

**Ключевые атрибуты**: `id`, `name`, `parentId`.

---

### 2.3. RawMaterial (сырьё)

Закупаемые материалы, используемые в производстве. Не являются товарами для продажи.

**Ключевые атрибуты**: `id`, `name`, `baseUnit` (г, мл, шт).

---

### 2.4. Packaging (упаковка)

**Packaging** — отдельный домен, не являющийся ингредиентом.

**Примеры**:
* стакан 200 / 300 / 400 мл;
* крышка маленькая / большая;
* трубочка, мешалка.

**Ключевые атрибуты**: `id`, `name`, `type` (например, `CUP`, `LID`, `ACCESSORY`).

**Важно**: Один товар может использовать **несколько упаковочных элементов**. Для напитков обязателен минимум один элемент типа `CUP`.

---

### 2.5. ProductPackaging (связь товара и упаковки)

Промежуточная сущность, определяющая, какая упаковка и в каком количестве используется для конкретного товара.

**Ключевые атрибуты**: `id`, `productId`, `packagingId`, `quantity` (количество единиц упаковки на один товар).

---

### 2.6. TechCard (технологическая карта)

Описывает рецептуру для товаров типа `manufactured`. Существует в строгой связи «один товар — одна активная техкарта».

**Ключевые атрибуты**: `id`, `productId`, `outputQuantity`, `outputUnit`, `version`.

**Активная техкарта**: Для расчёта всегда используется запись с максимальным значением `version` для данного `productId`.

---

### 2.7. TechCardIngredient (состав техкарты)

Связь между техкартой и сырьём, определяющая норму расхода.

**Ключевые атрибуты**: `id`, `techCardId`, `rawMaterialId`, `quantity`, `unit`, `wasteFactor` (коэффициент потерь).

---

### 2.8. PriceRecord (универсальная цена)

Единая версионированная сущность для хранения всех типов цен.

**Типы (`entityType`)**:
* `RAW_MATERIAL` — цена на сырьё;
* `PACKAGING` — цена на элемент упаковки;
* `RESALE_PRODUCT` — закупочная цена для перепродаваемого товара;
* `SALE_PRODUCT` — цена продажи товара.

**Ключевые атрибуты**: `id`, `entityType`, `entityId` (ссылка на сырьё, упаковку или товар), `price`, `currency`, `validFrom` (дата начала действия), `metadata`.

**Для `SALE_PRODUCT`**: Поле `metadata` содержит модель ценообразования, например: `{ "pricingModel": "markup", "value": 100 }` (где 100 = 100% наценки) или `{ "pricingModel": "margin", "value": 50 }` (где 50 = фиксированная наценка в 50 руб.).

---

### 2.9. CostCalculation (расчёт себестоимости)

Зафиксированный результат расчёта себестоимости товара на конкретную дату. Не изменяется при пересчёте цен в будущем.

**Ключевые атрибуты**: `id`, `productId`, `calculatedAt`, `totalCost`, `source` (`TECH_CARD` или `PURCHASE_PRICE`), `breakdown` (JSON-снимок использованных данных).

**Breakdown для manufactured-товара** включает детализацию по ингредиентам и упаковке:
```json
{
  "ingredients": [
    { "rawMaterialId": "...", "price": 5, "quantity": 0.05, "cost": 0.25 }
  ],
  "packaging": [
    { "packagingId": "...", "price": 10, "quantity": 1, "cost": 10 }
  ],
  "totalCost": 85.50
}
```

---

### 2.10. Связи между сущностями (ключевые отношения)

*   **Product** `manufactured` **имеет одну** активную **TechCard** (связь один-к-одному через `productId`).
*   **Product** **может иметь много** элементов упаковки через сущность **ProductPackaging** (связь многие-ко-многим).
*   **TechCard** **состоит из многих** **TechCardIngredient**, каждый из которых **ссылается на** один **RawMaterial**.
*   **PriceRecord** **ссылается на** одну целевую сущность (`RawMaterial`, `Packaging` или `Product`) через пару полей `entityType` и `entityId`.
*   **CostCalculation** **всегда принадлежит** одному **Product**.
*   Изменение упаковки (через **ProductPackaging**) **не влияет на версию TechCard**.

---

## 3. Инварианты упаковки (обязательные правила)

1. Товар может иметь **0..N упаковочных элементов**.
2. Для напитков обязателен минимум один элемент типа `CUP`.
3. Упаковка не входит в TechCard и не влияет на рецептуру.
4. Изменение упаковки **не меняет версию TechCard**.

---

## 4. Алгоритм расчёта себестоимости (с упаковкой)

### 4.1. Общая формула

```
TotalCost = IngredientsCost + PackagingCost
```

---

### 4.2. IngredientsCost (manufactured)

1. Найти активную **TechCard** для товара (запись с максимальным `version`).
2. Для каждого **TechCardIngredient** в составе техкарты:
   *   Определить актуальную цену сырья: найти **PriceRecord** с `entityType='RAW_MATERIAL'`, `entityId=<сырьё>` и максимальной датой `validFrom`, не превышающей дату расчёта.
   *   Привести `quantity` к `baseUnit` сырья, если единицы измерения различаются.
   *   **Стоимость ингредиента** = `quantity * price * (wasteFactor || 1.0)`.
3. **IngredientsCost** = сумма стоимостей всех ингредиентов.

---

### 4.3. PackagingCost

1. Найти все **ProductPackaging**, связанные с товаром.
2. Для каждого элемента:
   *   Определить актуальную цену упаковки: найти **PriceRecord** с `entityType='PACKAGING'`, `entityId=<упаковка>` и максимальной датой `validFrom`, не превышающей дату расчёта.
   *   **Стоимость элемента упаковки** = `ProductPackaging.quantity * price`.
3. **PackagingCost** = сумма стоимостей всех элементов упаковки.

---

### 4.4. Resale‑товары

Для товаров типа `resale`:
```
TotalCost = PurchasePrice
```
**PurchasePrice** — актуальная **PriceRecord** с `entityType='RESALE_PRODUCT'` для данного товара.
Упаковка считается включённой в закупочную цену, если не указано иначе.

---

### 4.5. Фиксация расчёта

1.  После вычисления `TotalCost` система создаёт запись **CostCalculation**.
2.  В поле `breakdown` сохраняется JSON-снимок всех использованных в расчёте данных: цены сырья и упаковки, количества, итоговые стоимости. Это гарантирует **воспроизводимость** расчёта даже после изменения цен в будущем.
3.  Поле `calculatedAt` устанавливается равным дате, на которую производился расчёт (обычно текущая дата).

---

## 5. Ценообразование

Поддерживаются модели:

1.  **Markup (наценка в процентах)**: `salePrice = cost * (1 + markupPercent / 100)`
2.  **Absolute margin (фиксированная наценка)**: `salePrice = cost + marginValue`

**Применение модели**:
*   Пользователь выбирает модель и задаёт параметр (`markupPercent` или `marginValue`) при установке цены продажи.
*   Система создаёт **PriceRecord** с `entityType='SALE_PRODUCT'`, где в `metadata` сохраняет выбранную модель и значение, например: `{ "pricingModel": "markup", "value": 100 }`.
*   При изменении себестоимости (`CostCalculation`) цена продажи может быть автоматически пересчитана по той же модели, если это предусмотрено логикой приложения.

---

## 6. Хранение данных (высокоуровнево)

### Backend (PostgreSQL)

*   Хранит канонические данные.
*   Гарантирует целостность и версионирование.
*   Выполняет финальные расчёты и валидации.

### Frontend (RxDB)

*   Хранит локальные копии данных.
*   Поддерживает офлайн‑режим.
*   Синхронизируется с сервером через push/pull.

Схемы БД и RxDB считаются **реализационной деталью** и могут эволюционировать без изменения доменной модели.

---

## 7. Архитектурные принципы

*   **Product — центральная сущность**.
*   **TechCard и Packaging — независимые домены** (изменение упаковки не затрагивает рецептуру).
*   **Все цены версионируются во времени** через единую сущность `PriceRecord`.
*   **Себестоимость фиксируется** и не пересчитывается задним числом.
*   Система решает **управленческие задачи**, а не бухгалтерские (фокус на расчёте и анализе, а не на проводках).

---

## 8. Масштабирование

Модель поддерживает:

*   Несколько точек продаж (через добавление атрибута `locationId` к ключевым сущностям).
*   Разных поставщиков (чевязь `PriceRecord` с поставщиком).
*   Изменение упаковки без изменения рецептуры.
*   Аналитику маржи и чувствительности к ценам сырья/упаковки.
*   Внедрение комплектов и комбо‑товаров (как новый тип `Product` с виртуальной структурой).